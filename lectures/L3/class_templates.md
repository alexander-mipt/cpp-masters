# Class templates

## 3 frontend fundamental principles

### Семантический анализ

1. Разрешение перегрузки (имен)
2. Вывод типов
3. Инстанцирование + разрешение зависимых имен 



## Разрешение имен шаблонных функций

Преобразования бывают:

1. Стандартные

   ![image-20221215142858227](media/image-20221215142858227.png)

2. Пользовательские преобразования

Например, `implicit operator`, `implicit class constructor`.

![image-20221215143537836](media/image-20221215143537836.png)

**Цепочка преобразований состоит из 0-1 пользовательского преобразования и хвоста+головы стандартных преобразований. Они ранжируются только по длине хвоста!**

![image-20221215144107323](media/image-20221215144107323.png)

Тут более одного пользовательского преобразования - ошибка. Эта такая защита от метопрограммирования на разрешении имен.

![image-20221215152547939](media/image-20221215152547939.png)

Специализации не участвуют в перегрузках (в разрешении имен).

Если убрать 2 последние строчки - выиграет 2. Иначе - 3.

## Перегрузка: шаблон против шаблона

![image-20221215154234201](media/image-20221215154234201.png)

Выиграет 2.

Здесь между шаблонами строит отношение частичного порядка, и выбирает тот кейс, который более узкоспециализирован.

![image-20221215154412613](media/image-20221215154412613.png)

![image-20221215154443270](media/image-20221215154443270.png)

Если отношение частичного порядка не удалось сделать - ошибка компиляции.

## Метод самок оленей

![image-20221215154728857](media/image-20221215154728857.png)

Специализация принадлежит победившей перегрузке шаблонов.

![image-20221215154913564](media/image-20221215154913564.png)

Шаблон - олень, специализация - самка. 3й олень пришел позже 1-го оленя, а потому не участвовал в борьбе.

## Олени и крокодилы

![image-20221215160831045](media/image-20221215160831045.png)

Выиграет 1, т.к. 2 в данном случае является крокодилом.

3. Функции с троеточиями (с самым низким приоритетом по разрешению имен)



## Точка объявления

Точка объявления - это место, где компилятору становится известно имя.

![image-20221215161307874](media/image-20221215161307874.png)

![image-20221215161443636](media/image-20221215161443636.png)

У `fnode` можно опустить `Т`, т.к. объявление уже произошло.

![image-20221215161638578](media/image-20221215161638578.png)

## Немного о метапрограммировании 

Метапрограммировать можно на инстанцировании.

![image-20221215162147127](media/image-20221215162147127.png)

Здесь порождается зависимый процесс инстанцирования.

## Специализация после инстанцирования - опасная вещь

![image-20221215163138382](media/image-20221215163138382.png)

> Об ODR:
>
> ODR for noinline functions - 1 for executable
>
> ODR for types - 1 for 1 translation unit 

Специализации типов нужно делать в заголовочниках, иначе могут возникнуть проблемы со специализациями.

![image-20221215164911228](media/image-20221215164911228.png)

В danger2.cc мы делаем forward declaration struct D и специализацию.

 ![image-20221215164953441](media/image-20221215164953441.png)

![image-20221215165216024](media/image-20221215165216024.png)

# Частичная специализация шаблонных классов

![image-20221215170408059](media/image-20221215170408059.png)

В классах после того, как шаблонный параметр определен в непосредственном контексте, он в том же виде пробрасывается в тело шаблонного класса.

![image-20221215170606204](media/image-20221215170606204.png)

Задачи на частичную специализацию

![image-20221215170644349](media/image-20221215170644349.png)

![image-20221215171205045](media/image-20221215171205045.png)

Нельзя заводит специализации, которые ничуть не менее обшие.

Причем не обязательно в частичной специализации должно быть <= число шаблонных параметров `primary template`.

![image-20221215171836431](media/image-20221215171836431.png)

**Частичная специализация для функций невозможна. Но мы можем завести частичные специализации для класса со статическим методом.**

![image-20221215172023339](media/image-20221215172023339.png)

![image-20221215172048800](media/image-20221215172048800.png)

Можно ли считать частичную специализацию формой наследования?

Нет, не выполняется принцип подстановки Лисков (один из принципов SOLID) - derivative is a base. 

![image-20221215173215916](media/image-20221215173215916.png)

Как писать шаблоны методов?

![image-20221215173348650](media/image-20221215173348650.png)

![image-20221215173532275](media/image-20221215173532275.png)

Но может возникать синтаксическая неоднозначность. Поэтому лучше перестраховываться. Для шаблонных методов можно явно указать:

![image-20221215173635679](media/image-20221215173635679.png)

А как писать специализацию для шаблононных методов?

![image-20221215173902387](media/image-20221215173902387.png)

![image-20221215173948740](media/image-20221215173948740.png)

Это трактуется как частичная специализация функции с одним неявным аргументом - this. **Частичная специализация функций невозможна.**

![image-20221215175028459](media/image-20221215175028459.png)

Как параметризовать методы?

![image-20221215175227375](media/image-20221215175227375.png)

![image-20221215175424072](media/image-20221215175424072.png)

![image-20221215175709272](media/image-20221215175709272.png)

![image-20221215175918560](media/image-20221215175918560.png)

![image-20221215180144124](media/image-20221215180144124.png)

## Виды типизации

* Статическая:
  * Номитативная
  * Утиная

