# Лекция 3

## Вывод типов в классах

Это поддержано с помощью вывода типов в конструкторах классов.

![image-20221215180756002](media/image-20221215180756002.png)

Но в классах не всегда может вывестись тип.

![image-20221215180857885](media/image-20221215180857885.png)

Это решается с помощью хинтов.

![image-20221215180957512](media/image-20221215180957512.png)

Хинты применимы и для классов, в которых нет конструкторов, есть только агрегатная инициализация.

![image-20221215181151157](media/image-20221215181151157.png)

У классов с конструкторами есть implicit hints.

![image-20221215181253497](media/image-20221215181253497.png)

# Лекция 4

В предыдущей лекции мы использовали переходник типов для того, чтобы симмитировать частичную специализацию для шаблонных методов.

> Ключевое слово `private` сохраняет не данные, а имена.

*В классах сначала выигрывается перегрузка, а потом обращается внимание на модификаторы полей/методов.* **Т.е. при перегрузке  модификаторы доступа игнорируются.**

![image-20221215183640176](media/image-20221215183640176.png)

А как насчет  порядка разрешения имен и инстанцирования?

## Двухфазное разрешение имен в шаблонах

![image-20221215184131267](media/image-20221215184131267.png)

![image-20221215184229685](media/image-20221215184229685.png)

Т.е. откладываются те имена, которые, грубо скажем, зависят от шаблонного параметра.

### Разрешение зависимых имен откладывается до подстановки шаблонного параметра!

![image-20221215184504964](media/image-20221215184504964.png)

На экране будет:

```
T S
```

![image-20221215184627019](media/image-20221215184627019.png)

### Пример Вандерворда

![image-20221215184836070](media/image-20221215184836070.png)

Проблема в том, что exit - не зависимое от шаблонного параметра имя, и разрешение имени не отложится во вторую фазу, и вызовется `std::exit()`. Ключевое слово`this`решает эту проблему.

### Немного о дизамбигуации

Дизамбигуация требуется для зависимых от шаблона имен/методов.

![image-20221215185647909](media/image-20221215185647909.png)

> С высокой вероятностью disambiguation требуется, когда шаблонный параметр еще не подставлен.



### Олени, самки оленей для шаблонных классов

Как выбирается частичная специализация для классов? 

![image-20221215191003661](media/image-20221215191003661.png)

**Если неизвестно, какой должен быть ответ - есть интуитивное правило: более специальное является приоритетным.**

Как выстроить отношение частичного порядка между частичными специализациями классов?  В функциях мы использовали вывод типов, но в классах может не быть конструкторов, и вывод типов

![image-20221215194447988](media/image-20221215194447988.png)

# Введение в модули

Объявление (`forward declaration`), определение, объявление + определение.

Файл из объявлений, часть из которых может содержать определения, есть **единица трансляции.**

![image-20221215195036432](media/image-20221215195036432.png)

Единицы трансляции нужны для разделения компиляции, для создания библиотек (как статических, так и динамических).

## Одна из проблем, решаемая заголовочным файлом

Чтобы застраховать соответствие объявления определению, можно использовать заголовочный файл с вынесенными в него определениями, и включить его во все места, где есть объявления и определения.

![image-20221215195703678](media/image-20221215195703678.png)

## Виды связываний

* Никакое 
* Внешнее
* Внутреннее
* Модульное

![image-20221215200628083](media/image-20221215200628083.png)

1 - внешнее

2 - внутреннее

3 - внешнее

4 - никакое (не может прийти из другого модуля)

5 - template declaration - гипотетически может быть вызван из другого модуля

6 - внутреннее

7 - внешнее

8 - внешнее

9 - внешнее

![image-20221215203608470](media/image-20221215203608470.png)

Нужно задаваться двумя вопросами:

* Definition может использоваться в другом модуле?
* Declaration может прийти из другого модуля

> Scope функции не определяет namespace
>
> Scope class определяет namespace

У библиотеки / исполняемого файла есть таблица символов. Однако в случае когда линковка состоялась, то перелинковка имен невозможна (по умолчанию).

> Почему не выдаем ошибку линкера в случае ODR violation?

В этом случае не возможно было бы слинковать стандартную библиотеку:

```
libgсс + link ligcc; libgcc + link libc 
```

Многопроходный линкер - это Ад.

![image-20221215211200880](media/image-20221215211200880.png)

По стандарту типы с одним именем в разных единицах трансляции в одной программе должны по-лексемно совпадать. В противном случае - UB.

![image-20221215212004176](media/image-20221215212004176.png)

 

## История с inline

Подставить тело функции в место ее вызова - это определение устарело для inline. Да, оно на 30% повышает вероятность inline.

Современная трактовка - исключение из ODR. Это позволит написать тело функции в заголовочном файле без опаски нарушения ODR.

![image-20221215213822721](media/image-20221215213822721.png)

![image-20221215221800894](media/image-20221215221800894.png)

Так как специализации нужно иметь в заголовочном файле (см. лекцию 3), то для того, чтобы обезопасить себя от ODR violation или UB лучше писать inline in header.

![image-20221215222430659](media/image-20221215222430659.png)

Если переменная нигде в программе не ODR-used, то ее definitions может быть сколько угодно.

Constexpr выкидывает ветки из инстанцирования.

